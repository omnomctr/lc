#! /usr/bin/lc -run

# lc is able to do combinatory logic, although it might be very slow at it
# https://en.wikipedia.org/wiki/Combinatory_logic

S := λx.λy.λz.x z (y z); # Sxyz = (xz)(yz)
K := λx.λy.x;            # Kxy = x
I := λx.x;               # Ix = x

# B and C can be made with S and K, but I 
# chose to represent them as their lambda terms
# for permance reasons
B := λx.λy.λz.x (y z);   # Bxyz = x(yz)
C := λx.λy.λz.x z y;     # Cxyz = (xz)y

# inc := λnfx.f(nfx);
#      = λnf.Bf(nf)
#      = λn.SBn
#      = SB
inc := S B;
# mult := λnmf.n(mf) == B
mult := B;
# is0 := λn.n(K(KI))K
#      = C(CI(K(KI)))K
is0 := C (C I (K (K I))) K;
# cons := λabf.fab;
#       = λab.C(CIa)b
#       = λa.C(CIa)
#       = BC(CI)
cons := B C (C I);
# car := λp.p true
#      = λp.p K
#      = CIK
car := C I K;
# cdr := λp.p false;
#      = λp.p (KI);
#      = CI(KI);
cdr := C I (K I);
# shiftinc := λp.cons (cdr p) (inc (cdr p))
#           = S(B cons cdr) (B inc cdr)
shiftinc := S (B cons cdr) (B inc cdr);
# dec := λn.car (n shiftinc (cons 0 0));
#      = λn.car (n shiftinc (cons 0 0));
#      = B car (C (C I shiftinc) (cons 0 0));
dec := B car (C (C I shiftinc) (cons 0 0));

# Y := λf.(λx.f (x x))(λx.f (x x));
#    = λf.(λg.g g) (λx.f (x x));
#    = λf.(SII)(Bf(SII))
#    = B(SII)(CB(SII))
Y := B (S I I) (C B (S I I));

# fact := Y (λf.λn.is0 n 1 (mult n (f (dec n))))
#       = Y(λf.S(C is0 1)(S mult (B f dec)))
#       = Y(B(S(C is0 1))(B(S mult)(CB dec)))
fact := Y (B (S (C is0 1)) (B (S mult) (C B dec)));
fact 3; # might take a very long time to evaluate
