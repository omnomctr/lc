#! /usr/bin/lc -run

# lambda abstractions can be written with either a
# lambda (λ) or a singular backslash (\).
# Variables can also be multiple characters long but other than
# that the syntax is pretty standard

# definitions 
inc := λn.λf.λx.f (n f x);

add := λn.λm.λf.λx.n f (m f x);
mult := λn.λm.λf.n (m f);

true := λa.λb.a;
false := λa.λb.b;

and := λa.λb.a b a;
or := λa.λb.a a b;
not := λa.a false true;

cons := λa.λb.λf.f a b;
car := λp.p true;
cdr := λp.p false;

# (m, n) -> (n, n + 1)
shiftinc := λp.cons (cdr p) (inc (cdr p));

dec := λn.car (n shiftinc (cons 0 0));
sub := λn.λm.m dec n;
is0 := λn.n (λx.false) true;

Y := λf.(λx.f (x x)) (λx.f (x x));

fact := Y (λf.λn.is0 n 1 (mult n (f (dec n))));

# run your expression at the end of the file
# numbers are encoded as church numerals, 4 is converted to λf.λx.f (f (f (f x)))
fact 4;
